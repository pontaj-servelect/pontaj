<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SERVELECT ‚Ä¢ Rapoarte Pontaj</title>
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700;800&display=swap" rel="stylesheet">
  <link rel="icon" href="favicon.png" />
  <meta name="theme-color" content="#516A75"/>
  <style>
    :root{
      --brand:#516B74;
      --brand-weak:rgba(81,106,117,0.88);
      --accent:#95CA4B;
      --text:#0f172a;
      --muted:#5b6b73;
      --bg:#f4f7f9;
      --card:#ffffff;
      --ring:#cfe0e7;
      --danger:#ef4444;
      --warn:#f59e0b;
    }
    *{box-sizing:border-box}
    html,body{height:100%; width:100%}
    body{
      margin:0;
      font-family: Montserrat, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color:var(--text);
      background:
        linear-gradient(180deg, rgba(149, 202, 75, 0.91) 0%, rgba(81, 106, 117, 0.88) 66%),
        url('background.jpg');
      background-size: cover;
      background-position: center center;
      background-repeat: no-repeat;
      background-attachment: fixed;
      min-height:100vh;
    }
    .shell{max-width:1200px;margin:0 auto;padding:24px;}
    .nav{
      display:flex;align-items:center;justify-content:space-between;
      gap:16px;padding:14px 16px;border-radius:16px;
      background:linear-gradient(180deg, rgba(255,255,255,.95), rgba(255,255,255,.80));
      backdrop-filter: blur(8px);
      box-shadow: 0 8px 30px rgba(81,106,117,.18);
      border:1px solid rgba(81,106,117,.18);
    }
    .brand{display:flex;align-items:center;gap:12px;text-decoration:none;color:inherit}
    .brand img{ width:38px;height:38px;object-fit:contain;aspect-ratio:1/1;border-radius:10px;box-shadow:0 3px 10px rgba(81,106,117,.25) }
    .brand h1{font-size:18px;letter-spacing:.2px;margin:0;line-height:1.1}
    .brand h1 span{display:block;font-weight:700}
    .brand small{display:block;font-size:12px;color:var(--muted);margin-top:2px}

    .nav-actions{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      background:rgba(81,106,117,.10);
      color:#2f3e45;
      font-weight:600;
      font-size:12px;
    }

    .card{
      background:var(--card);
      border:1px solid rgba(14,165,233,.12);
      border-radius:18px;
      box-shadow: 0 20px 60px rgba(2,132,199,.08);
    }

    .admin-layout{
      margin-top:20px;
      display:grid;
      grid-template-columns: minmax(0,2.5fr) minmax(260px,1fr);
      gap:18px;
      align-items:flex-start;
    }
    @media (max-width:960px){
      .admin-layout{ grid-template-columns:1fr; }
    }

    .admin-main{
      padding:18px 18px 16px;
      border-radius:18px;
      background:rgba(248,250,252,.92);
      backdrop-filter: blur(6px);
      border:1px solid rgba(148,163,184,.25);
    }

    .admin-header{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-bottom:14px;
    }
    .admin-header h1{
      margin:0;
      font-size:20px;
    }
    .admin-header p{
      margin:0;
      font-size:13px;
      color:var(--muted);
    }

    .admin-card{
      padding:14px 14px 12px;
    }
    .admin-card h2{
      margin:0 0 4px;
      font-size:16px;
    }
    .admin-small-text{
      font-size:12px;
      color:var(--muted);
      margin-bottom:10px;
    }

    .btn{
      --bg:#e2e8f0;
      --fg:#0f172a;
      appearance:none;
      border:0;
      border-radius:12px;
      padding:10px 14px;
      font-weight:600;
      cursor:pointer;
      transition: transform .06s ease, box-shadow .2s ease, background .2s;
      box-shadow:0 6px 16px rgba(15,23,42,.08);
      color:var(--fg);
      background:var(--bg);
      font-size:13px;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      gap:6px;
      justify-content:center;
      white-space:nowrap;
    }
    .btn:active{ transform:translateY(1px); }
    .btn.primary{
      --bg:var(--danger);
      --fg:#fff;
    }

    .reports-actions{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
    }

    .admin-side{
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    .admin-link{
      color:var(--brand);
      text-decoration:none;
      font-weight:600;
      font-size:13px;
    }
    .admin-link:hover{
      text-decoration:underline;
    }

    .admin-log{
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", Courier, monospace;
      font-size:11px;
      background:#020617;
      color:#e5e7eb;
      border-radius:10px;
      padding:10px 12px;
      max-height:240px;
      overflow:auto;
      white-space:pre;
    }
    .reports-files-list{
      margin-top:6px;
      padding-left:16px;
      font-size:12px;
    }
    .reports-files-list li{
      margin-bottom:4px;
    }
    .reports-files-list a{
      color:var(--brand);
      text-decoration:none;
      font-weight:600;
    }
    .reports-files-list a:hover{
      text-decoration:underline;
    }

  </style>
</head>
<body>
  <div class="shell">
    <nav class="nav card">
      <a class="brand" href="index.html" aria-label="Spre pontaj">
        <img src="favicon.png" alt="SiglƒÉ SERVELECT" />
        <div>
          <h1><span>SERVELECT</span><small>Pontaj & Management Concedii</small></h1>
        </div>
      </a>

      <div class="nav-actions">
        <a href="admin.html" class="btn">
          ‚Üê √énapoi la dashboard
        </a>
        <div class="chip">Rapoarte manuale</div>
      </div>
    </nav>

    <main class="admin-layout">
      <section class="admin-main">
        <header class="admin-header">
          <h1>Rapoarte pontaj ‚Äì executare manualƒÉ</h1>
          <p>
            Aici po»õi for»õa rularea rapoartelor de tip <b>dailyReports</b>, <b>weeklyReports</b>,
            <b>monthlyReports</b> »ôi <b>rebuildAllReports</b>, exact ca triggerele din Apps Script.
            E util c√¢nd trebuie ‚Äûfor»õate‚Äù rapoartele sau testezi modificƒÉri.
          </p>
        </header>

        <section class="card admin-card">
          <h2>GenereazƒÉ rapoarte</h2>
          <p class="admin-small-text">
            Fiecare buton apeleazƒÉ endpoint-ul Apps Script (<code>adminEventsEndpoint</code>)
            al WebApp-ului cu parametrii direc»õi:
            <code>?fn=dailyReports</code>, <code>?fn=weeklyReports</code>,
            <code>?fn=monthlyReports</code>, <code>?fn=rebuildReports</code>.
            Alternativ se poate folosi »ôi endpoint-ul generic:
            <code>?fn=reports&amp;type=daily|weekly|monthly|rebuild</code>.
          </p>

          <div class="reports-actions" style="margin-bottom:10px;">
            <button id="dailyReportBtn" type="button" class="btn primary">
              üìÖ Raport zi (dailyReports)
            </button>
            <button id="weeklyReportBtn" type="button" class="btn">
              üóì Raport sƒÉptƒÉm√¢nƒÉ (weeklyReports)
            </button>
            <button id="monthlyReportBtn" type="button" class="btn">
              üìÜ Raport lunƒÉ (monthlyReports)
            </button>
            <!-- NOU -->
            <button id="monthlyCurrentReportBtn" type="button" class="btn">
              üìÜ Raport lunar current (monthlyReportsLatest)
            </button>
            <!-- /NOU -->
            <button id="rebuildReportBtn" type="button" class="btn">
              ‚ôªÔ∏è Rebuild statistici (rebuildReports)
            </button>
          </div>

          <div id="reportsStatus" class="admin-small-text">
            Nicio ac»õiune rulatƒÉ √ÆncƒÉ.
          </div>

          <pre id="reportsLog" class="admin-log">‚Äì</pre>
          <div id="reportsFiles" class="admin-small-text" style="margin-top:8px">
            Niciun raport de descƒÉrcat √ÆncƒÉ.
          </div>

          <h2>Exporturi pontaj</h2>
          <p class="admin-small-text">
            Exporturi CSV »ôi PDF bazate pe <b>filtrul curent</b> salvat √Æn dashboard-ul de pontaj
            (perioadƒÉ / departament / angajat / zile incomplete).
          </p>

          <div class="reports-actions" style="margin-bottom:10px;">
            <button id="exportCsvBtn" class="btn" type="button">
              üìÑ Export CSV (filtru curent)
            </button>
            <button id="exportIncompleteBtn" class="btn" type="button">
              ‚ö† Export zile incomplete
            </button>
            <button id="exportAnomaliesBtn" class="btn" type="button">
              ‚ö† Export anomalii
            </button>
            <button id="pdfBtn" class="btn" type="button">
              üìë PDF angajat selectat
            </button>
            <button id="deptPdfBtn" class="btn" type="button">
              üè¢ PDF departament (luna precedentƒÉ)
            </button>
            <button id="employeeExportBtn" class="btn" type="button">
              üë§ Export CSV angajat (all time)
            </button>
            <button id="payrollExportBtn" class="btn" type="button">
              üí∞ Export salarizare (luna precedentƒÉ)
            </button>
          </div>

          <p class="admin-small-text">
            Pentru PDF »ôi exporturile per angajat se folose»ôte angajatul selectat √Æn filtrul din dashboard.
            AsigurƒÉ-te cƒÉ ai setat filtrul dorit √Æn
            <a href="admin.html" class="admin-link">Dashboard pontaj</a>
            √Ænainte de a rula exporturile.
          </p>
        </section>
      </section>

      <aside class="admin-side">
        <section class="card admin-card">
          <h2>Sesiune admin</h2>
          <p class="admin-small-text">
            Conectat ca <b id="adminLabel">Admin</b>.
          </p>
          <button id="logoutBtn" class="btn primary" type="button">Deconectare</button>
          <p class="admin-small-text" style="margin-top:10px">
            <a href="admin.html" class="admin-link">‚Üê √énapoi la dashboard pontaj</a>
          </p>
        </section>

        <section class="card admin-card">
          <h2>Info tehnic</h2>
          <p class="admin-small-text">
            RƒÉspunsul de la server este afi»ôat mai jos √Æn log. Ideal, Apps Script ar trebui sƒÉ
            returneze un JSON de forma:
            <code>{"ok":true,"msg":"Raport generat"}</code> sau <code>{"ok":false,"error":"..."}</code>.
          </p>
        </section>
      </aside>
    </main>
  </div>

  <script>
    (function(){
      const ADMIN_LS_KEY = 'pontaj/admin/v1';
      const FILTER_LS_KEY = 'pontaj/admin/filters';

      let GLOBAL_CFG = null;

      let DEFAULT_NORM_MS = 8 * 60 * 60 * 1000;
      let LONG_NORM_MS = 8.5 * 60 * 60 * 1000;
      let DEFAULT_PAUSE_MARGIN_MS = 40 * 60 * 1000;
      const ACTIVITATI_NORMA_8H30 = ['deplasare','pe drum','atelier'];

      let NORM_CFG = null;
      let LEAVE_BY_DAY = new Map();
      let REPORT_EVENTS = [];
      let REPORT_STATS = null;

      const TZ = 'Europe/Bucharest';

      function getAdminSession(){
        try{
          const raw = localStorage.getItem(ADMIN_LS_KEY);
          return raw ? JSON.parse(raw) : null;
        }catch{
          return null;
        }
      }

      function clearAdminSession(){
        try{ localStorage.removeItem(ADMIN_LS_KEY); }catch{}
      }

      async function loadConfig(){
        if (GLOBAL_CFG) return GLOBAL_CFG;
        const r = await fetch('config.json?v=' + Date.now(), {cache:'no-store'});
        if (!r.ok) throw new Error('Nu pot citi config.json (HTTP ' + r.status + ').');
        GLOBAL_CFG = await r.json();
        return GLOBAL_CFG;
      }

      function getWebAppBaseUrl() {
        if (!GLOBAL_CFG || !GLOBAL_CFG.adminEventsEndpoint) {
          throw new Error('Lipse»ôte adminEventsEndpoint √Æn config.json.');
        }
        // ex: https://script.google.com/macros/s/.../exec?fn=adminEvents
        // -> baza devine .../exec
        return GLOBAL_CFG.adminEventsEndpoint.split('?')[0].replace(/\/$/, '');
      }

      function appendLogLine(logEl, text){
        if (!logEl) return;
        const now = new Date();
        const hh = String(now.getHours()).padStart(2,'0');
        const mi = String(now.getMinutes()).padStart(2,'0');
        const ss = String(now.getSeconds()).padStart(2,'0');
        const line = '[' + hh + ':' + mi + ':' + ss + '] ' + text;
        if (logEl.textContent === '‚Äì' || !logEl.textContent){
          logEl.textContent = line;
        } else {
          logEl.textContent = line + '\n' + logEl.textContent;
        }
      }

      // ===== Func»õii utilitare pentru rapoarte / statistici =====

      function dateKeyFromIso(iso){
        if (!iso) return null;
        const d = new Date(iso);
        if (isNaN(d.getTime())) return null;
        return new Intl.DateTimeFormat('sv-SE', {
          timeZone: TZ,
          year:'numeric',
          month:'2-digit',
          day:'2-digit'
        }).format(d); // YYYY-MM-DD
      }

      function isWeekend(dateKey){
        if (!dateKey) return false;
        const parts = dateKey.split('-');
        if (parts.length !== 3) return false;
        const y = parseInt(parts[0],10);
        const m = parseInt(parts[1],10)-1;
        const d = parseInt(parts[2],10);
        const dt = new Date(y,m,d);
        if (isNaN(dt.getTime())) return false;
        const wd = dt.getDay();
        return wd === 0 || wd === 6;
      }

      function fmtDateTime(iso){
        if (!iso) return '';
        const d = new Date(iso);
        if (isNaN(d.getTime())) return '';
        const dd = String(d.getDate()).padStart(2,'0');
        const mm = String(d.getMonth()+1).padStart(2,'0');
        const yyyy = d.getFullYear();
        const hh = String(d.getHours()).padStart(2,'0');
        const mi = String(d.getMinutes()).padStart(2,'0');
        return `${dd}.${mm}.${yyyy} ${hh}:${mi}`;
      }

      function fmtHoursHM(ms){
        const totalMin = Math.round(ms / 60000);
        const h = Math.floor(totalMin / 60);
        const m = totalMin % 60;
        return `${h}h ${String(m).padStart(2,'0')}m`;
      }

      function msToHours(ms){
        return ms / 3600000;
      }

      function _normAction(a){
        let s = String(a == null ? '' : a).trim().toLowerCase().replace(/[-\s]+/g,'_');
        if (s === 'resume') s='unpause';
        if (s === 'stop') s='finish';
        if (s === 'extra start') s='extra_start';
        if (s === 'extra finish') s='extra_finish';
        return s;
      }

      function applyNormSettingsFromConfig(cfg){
        NORM_CFG = {
          timezone: (cfg.normSettings && cfg.normSettings.timezone) || 'Europe/Bucharest',
          defaultNormMs: DEFAULT_NORM_MS,
          defaultLongNormMs: LONG_NORM_MS,
          defaultPauseMarginMs: DEFAULT_PAUSE_MARGIN_MS,
          perDept: {},
          perEmployee: {}
        };
        if (cfg.normSettings){
          if (cfg.normSettings.default){
            if (typeof cfg.normSettings.default.normHours === 'number'){
              NORM_CFG.defaultNormMs = cfg.normSettings.default.normHours * 60 * 60 * 1000;
            }
            if (typeof cfg.normSettings.default.pauseMaxMinutes === 'number'){
              NORM_CFG.defaultPauseMarginMs = cfg.normSettings.default.pauseMaxMinutes * 60 * 1000;
            }
          }
          if (cfg.normSettings.departments){
            Object.keys(cfg.normSettings.departments).forEach(dep=>{
              const nd = cfg.normSettings.departments[dep] || {};
              NORM_CFG.perDept[dep] = {
                normMs: (typeof nd.normHours === 'number' ? nd.normHours * 60 * 60 * 1000 : null),
                pauseMarginMs: (typeof nd.pauseMaxMinutes === 'number' ? nd.pauseMaxMinutes * 60 * 1000 : null)
              };
            });
          }
          if (cfg.normSettings.employees){
            Object.keys(cfg.normSettings.employees).forEach(name=>{
              const ne = cfg.normSettings.employees[name] || {};
              NORM_CFG.perEmployee[name] = {
                normMs: (typeof ne.normHours === 'number' ? ne.normHours * 60 * 60 * 1000 : null),
                pauseMarginMs: (typeof ne.pauseMaxMinutes === 'number' ? ne.pauseMaxMinutes * 60 * 1000 : null)
              };
            });
          }
        }
      }

      function getNormMsFor(name, dept, hasLongActivity){
        const cfg = NORM_CFG || {};
        const empCfg = (cfg.perEmployee && name) ? cfg.perEmployee[name] : null;
        if (empCfg && empCfg.normMs) return empCfg.normMs;
        const depCfg = (cfg.perDept && dept) ? cfg.perDept[dept] : null;
        if (depCfg && depCfg.normMs) return depCfg.normMs;
        if (hasLongActivity){
          return cfg.defaultLongNormMs || LONG_NORM_MS;
        }
        return cfg.defaultNormMs || DEFAULT_NORM_MS;
      }

      function getPauseMarginMsFor(name, dept){
        const cfg = NORM_CFG || {};
        const empCfg = (cfg.perEmployee && name) ? cfg.perEmployee[name] : null;
        if (empCfg && typeof empCfg.pauseMarginMs === 'number') return empCfg.pauseMarginMs;
        const depCfg = (cfg.perDept && dept) ? cfg.perDept[dept] : null;
        if (depCfg && typeof depCfg.pauseMarginMs === 'number') return depCfg.pauseMarginMs;
        return cfg.defaultPauseMarginMs || DEFAULT_PAUSE_MARGIN_MS;
      }

      function buildLeaveIndex(leaves){
        LEAVE_BY_DAY = new Map();
        if (!Array.isArray(leaves)) return;
        leaves.forEach(item=>{
          if (!item || !item.name || !item.from || !item.to) return;
          const name = item.name;
          const status = (item.status || '').toLowerCase();
          if (status && status !== 'approved' && status !== 'aprobat') return;
          const start = new Date(item.from);
          const end   = new Date(item.to);
          if (isNaN(start.getTime()) || isNaN(end.getTime())) return;
          const cur = new Date(start.getFullYear(), start.getMonth(), start.getDate());
          const last= new Date(end.getFullYear(), end.getMonth(), end.getDate());
          while (cur.getTime() <= last.getTime()){
            const dk = dateKeyFromIso(cur.toISOString());
            if (!LEAVE_BY_DAY.has(dk)){
              LEAVE_BY_DAY.set(dk, new Set());
            }
            LEAVE_BY_DAY.get(dk).add(name);
            cur.setDate(cur.getDate() + 1);
          }
        });
      }

      function isEmployeeOnLeave(name, dateKey){
        if (!name || !dateKey || !LEAVE_BY_DAY) return false;
        const set = LEAVE_BY_DAY.get(dateKey);
        return !!(set && set.has(name));
      }

      function isDayIncomplete(day){
        if (!day) return false;
        const hasAnyEvent =
          (day.events && day.events.length) ||
          day.hasStart || day.hasFinish ||
          day.pauseCount || day.unpauseCount ||
          day.extraStartCount || day.extraFinishCount;
        if (!hasAnyEvent) return false;
        return (
          !day.hasFinish ||
          day.hasPauseMismatch ||
          day.hasExtraMismatch ||
          day.openExtra
        );
      }

      function getIncompleteReasons(day){
        const reasons = [];
        if (!day) return reasons;
        if (!day.hasFinish) reasons.push('FƒÉrƒÉ FINISH');
        if (day.hasPauseMismatch) reasons.push('PAUSE/UNPAUSE ne√Ænchise');
        if (day.hasExtraMismatch) reasons.push('EXTRA START/FINISH ne√Ænchise');
        if (day.openExtra) reasons.push('EXTRA rƒÉmas √Æn curs');
        return reasons;
      }

      function buildStatsFromEvents(events){
        const employees = new Map();
        const perDay    = new Map();

        function getEmp(name){
          if (!employees.has(name)){
            employees.set(name, {
              name,
              dept:'',
              days:new Map(),
              totals:{
                daysWithStart:0,
                daysWithFinish:0,
                daysCompleted:0,
                totalWorkMs:0,
                totalExtraMs:0,
                overtimeMs:0,
                firstEvent:null,
                lastEvent:null,
                normValidatedDays:0,
                incompleteDays:0
              }
            });
          }
          return employees.get(name);
        }

        const byNameDate = new Map();
        (events || []).forEach(ev => {
          if (!ev.ts || !ev.name) return;
          const dk = dateKeyFromIso(ev.ts);
          if (!dk) return;
          const key = ev.name + '||' + dk;
          if (!byNameDate.has(key)) byNameDate.set(key, []);
          byNameDate.get(key).push(ev);
        });

        byNameDate.forEach((evs, key) => {
          evs.sort((a,b)=>new Date(a.ts) - new Date(b.ts));
          const parts = key.split('||');
          const name  = parts[0];
          const dk    = parts[1];

          const emp = getEmp(name);
          let day = emp.days.get(dk);
          if (!day){
            day = {
              dateKey: dk,
              dept:'',
              events: evs,
              workMs:0,
              extraMs:0,
              pauseMs:0,
              hasStart:false,
              hasFinish:false,
              completed:false,
              overtimeMs:0,
              normMs: DEFAULT_NORM_MS,
              normValidated:false,
              incomplete:false,
              startCount:0,
              finishCount:0,
              pauseCount:0,
              unpauseCount:0,
              extraStartCount:0,
              extraFinishCount:0,
              openRunning:false,
              openExtra:false,
              hasPauseMismatch:false,
              hasExtraMismatch:false
            };
            emp.days.set(dk, day);
          } else {
            day.events = evs;
          }

          let hasLongActivity = false;
          evs.forEach(ev => {
            if (ev.dept) day.dept = ev.dept;
            if (ev.activity && ACTIVITATI_NORMA_8H30.indexOf(ev.activity) !== -1){
              hasLongActivity = true;
            }
          });
          day.normMs = getNormMsFor(name, day.dept, hasLongActivity);
          if (!emp.dept && day.dept) emp.dept = day.dept;

          let running        = false;
          let paused         = false;
          let extraRunning   = false;
          let startTs        = null;
          let pauseStartTs   = null;
          let extraStartTs   = null;
          let sumPauseMs     = 0;
          let workMs         = 0;
          let extraMs        = 0;

          evs.forEach(ev => {
            const t = new Date(ev.ts).getTime();
            if (isNaN(t)) return;
            const act = ev.action;

            if (act === 'start') {
              day.hasStart = true;
              day.startCount++;
              running = true;
              paused  = false;
              sumPauseMs   = 0;
              startTs      = t;
              pauseStartTs = null;
            } else if (act === 'pause') {
              day.pauseCount++;
              if (running && !paused) {
                paused       = true;
                pauseStartTs = t;
              }
            } else if (act === 'unpause') {
              day.unpauseCount++;
              if (running && paused) {
                paused = false;
                if (pauseStartTs != null) {
                  sumPauseMs += Math.max(0, t - pauseStartTs);
                  pauseStartTs = null;
                }
              }
            } else if (act === 'finish') {
              day.hasFinish = true;
              day.finishCount++;
              if (running && startTs != null) {
                if (paused && pauseStartTs != null) {
                  sumPauseMs += Math.max(0, t - pauseStartTs);
                  pauseStartTs = null;
                  paused = false;
                }
                const diff    = Math.max(0, t - startTs);
                const segment = Math.max(0, diff - sumPauseMs);
                workMs += segment;
              }
              running      = false;
              paused       = false;
              startTs      = null;
              pauseStartTs = null;
              sumPauseMs   = 0;
            } else if (act === 'extra_start') {
              day.extraStartCount++;
              extraRunning = true;
              extraStartTs = t;
            } else if (act === 'extra_finish') {
              day.extraFinishCount++;
              if (extraRunning && extraStartTs != null) {
                extraMs += Math.max(0, t - extraStartTs);
              }
              extraRunning = false;
              extraStartTs = null;
            }
          });

          day.workMs   = workMs;
          day.extraMs  = extraMs;
          day.pauseMs  = sumPauseMs;

          emp.totals.totalWorkMs  += workMs;
          emp.totals.totalExtraMs += extraMs;

          if (day.hasStart)  emp.totals.daysWithStart++;
          if (day.hasFinish) emp.totals.daysWithFinish++;

          day.openRunning      = day.hasStart && !day.hasFinish;
          day.openExtra        = day.extraStartCount > day.extraFinishCount;
          day.hasPauseMismatch = day.pauseCount !== day.unpauseCount;
          day.hasExtraMismatch = day.extraStartCount !== day.extraFinishCount;

          day.incomplete = isDayIncomplete(day);
          if (day.incomplete) emp.totals.incompleteDays++;

          if (day.hasStart && day.hasFinish && workMs > 0) {
            day.completed = true;
            emp.totals.daysCompleted++;
          }

          const normForDay     = day.normMs || getNormMsFor(name, day.dept || emp.dept || '', false);
          const pauseMarginMs  = getPauseMarginMsFor(name, day.dept || emp.dept || '');
          if (day.completed && workMs > normForDay){
            day.overtimeMs = workMs - normForDay;
            emp.totals.overtimeMs += day.overtimeMs;
          }

          day.normValidated = false;
          if (!day.incomplete && day.completed){
            const neededWorkMs = Math.max(0, normForDay - pauseMarginMs);
            const pauseMs      = day.pauseMs || 0;
            const hasMinWork   = workMs >= neededWorkMs;
            const pauseOk      = pauseMs <= pauseMarginMs;
            if (hasMinWork && pauseOk){
              day.normValidated = true;
              emp.totals.normValidatedDays++;
            }
          }

          let daySummary = perDay.get(dk);
          if (!daySummary) {
            daySummary = { dateKey: dk, started: new Set(), completed: new Set() };
            perDay.set(dk, daySummary);
          }
          if (day.hasStart)   daySummary.started.add(name);
          if (day.completed)  daySummary.completed.add(name);

          evs.forEach(ev => {
            const t = new Date(ev.ts).getTime();
            if (isNaN(t)) return;
            if (!emp.totals.firstEvent || t < new Date(emp.totals.firstEvent).getTime()) {
              emp.totals.firstEvent = ev.ts;
            }
            if (!emp.totals.lastEvent || t > new Date(emp.totals.lastEvent).getTime()) {
              emp.totals.lastEvent = ev.ts;
            }
          });
        });

        return { employees, perDay };
      }

      function applyDeptEmployee(events, dept, employee){
        let list = events.slice();
        if (dept && dept !== 'all'){
          list = list.filter(ev => (ev.dept || '(fƒÉrƒÉ departament)') === dept);
        }
        if (employee && employee !== 'all'){
          list = list.filter(ev => ev.name === employee);
        }
        return list;
      }

      function filterByRange(events, range){
        if (!events || !events.length) return [];
        const now = new Date();
        const endTime = now.getTime();
        if (range === 'all') return events.slice();
        let startTime;
        if (range === 'last7'){
          const d = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0,0,0,0);
          d.setDate(d.getDate() - 6);
          startTime = d.getTime();
        } else {
          const d = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0,0,0,0);
          startTime = d.getTime();
        }
        return events.filter(ev => {
          if (!ev.ts) return false;
          const t = new Date(ev.ts).getTime();
          if (isNaN(t)) return false;
          return t >= startTime && t <= endTime;
        });
      }

      function exportCsvGeneric(filename, header, rows){
        if (!rows || !rows.length){
          alert('Nu existƒÉ date pentru export.');
          return;
        }
        const csvLines = [header].concat(rows).map(row => row.map(cell => {
          const s = String(cell == null ? '' : cell).replace(/"/g,'""');
          return '"' + s + '"';
        }).join(','));
        const csv = csvLines.join('\r\n');
        const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
        const url  = URL.createObjectURL(blob);
        const a    = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(function(){
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        },0);
      }

      function getFilterState(){
        try{
          const raw = localStorage.getItem(FILTER_LS_KEY);
          if (!raw) throw new Error('no');
          const obj = JSON.parse(raw);
          return {
            range: obj.range || 'today',
            dept: obj.dept || 'all',
            employee: obj.employee || 'all',
            incompleteOnly: !!obj.incompleteOnly,
            selectedDay: obj.selectedDay || null,
            lastEventsRange: obj.lastEventsRange || 'today'
          };
        }catch(_){
          return {
            range:'today',
            dept:'all',
            employee:'all',
            incompleteOnly:false,
            selectedDay:null,
            lastEventsRange:'today'
          };
        }
      }

      function getEventsForCurrentFilter(){
        const fs = getFilterState();
        let baseAll = applyDeptEmployee(REPORT_EVENTS, fs.dept, fs.employee);
        let baseRange = filterByRange(baseAll, fs.range);
        if (fs.selectedDay){
          baseRange = baseAll.filter(ev => dateKeyFromIso(ev.ts) === fs.selectedDay);
        }
        if (!fs.incompleteOnly) return baseRange.slice();

        const stats = buildStatsFromEvents(baseRange);
        return baseRange.filter(ev => {
          if (!ev.name || !ev.ts) return false;
          const dk = dateKeyFromIso(ev.ts);
          if (!dk) return false;
          const emp = stats.employees.get(ev.name);
          if (!emp) return false;
          const day = emp.days.get(dk);
          return day && isDayIncomplete(day);
        });
      }

      function getIncompleteRowsForCurrentFilter(){
        const fs = getFilterState();
        let baseAll = applyDeptEmployee(REPORT_EVENTS, fs.dept, fs.employee);
        let baseRange = filterByRange(baseAll, fs.range);
        if (fs.selectedDay){
          baseRange = baseAll.filter(ev => dateKeyFromIso(ev.ts) === fs.selectedDay);
        }

        const stats = buildStatsFromEvents(baseRange);
        const keyMap = new Map();

        baseRange.forEach(ev => {
          if (!ev.name || !ev.ts) return;
          const dk = dateKeyFromIso(ev.ts);
          if (!dk) return;
          const key = ev.name + '||' + dk;
          if (!keyMap.has(key)){
            keyMap.set(key, { name:ev.name, dateKey:dk, deptHint:ev.dept || '' });
          }
        });

        const rows = [];
        keyMap.forEach(info => {
          const emp = stats.employees.get(info.name);
          if (!emp) return;
          const day = emp.days.get(info.dateKey);
          if (!day) return;
          if (!isDayIncomplete(day)) return;

          const isLeave = isEmployeeOnLeave(info.name, info.dateKey);
          const reasons = getIncompleteReasons(day);

          rows.push({
            dateKey: info.dateKey,
            name: info.name,
            dept: day.dept || emp.dept || info.deptHint || '',
            work: day.workMs ? fmtHoursHM(day.workMs) : '',
            extra: day.extraMs ? fmtHoursHM(day.extraMs) : '',
            leave: isLeave ? 'DA' : 'NU',
            status: reasons.length ? reasons.join('; ') : 'Incomplet'
          });
        });

        rows.sort((a,b)=>{
          if (a.dateKey < b.dateKey) return -1;
          if (a.dateKey > b.dateKey) return 1;
          return a.name.localeCompare(b.name,'ro');
        });
        return rows;
      }

      function getAnomalyRowsForCurrentFilter(){
        const fs = getFilterState();
        let baseAll = applyDeptEmployee(REPORT_EVENTS, fs.dept, fs.employee);
        let baseRange = filterByRange(baseAll, fs.range);
        if (fs.selectedDay){
          baseRange = baseAll.filter(ev => dateKeyFromIso(ev.ts) === fs.selectedDay);
        }

        const stats = buildStatsFromEvents(baseRange);
        const keyMap = new Map();

        baseRange.forEach(ev => {
          if (!ev.name || !ev.ts) return;
          const dk = dateKeyFromIso(ev.ts);
          if (!dk) return;
          const key = ev.name + '||' + dk;
          if (!keyMap.has(key)){
            keyMap.set(key, { name:ev.name, dateKey:dk, deptHint:ev.dept || '' });
          }
        });

        const rows = [];
        keyMap.forEach(info => {
          const emp = stats.employees.get(info.name);
          if (!emp) return;
          const day = emp.days.get(info.dateKey);
          if (!day) return;

          const reasons = [];
          const normForDay = day.normMs || getNormMsFor(info.name, day.dept || emp.dept || '', false);
          const pauseMarginMs = getPauseMarginMsFor(info.name, day.dept || emp.dept || '');

          if (day.hasPauseMismatch){
            reasons.push('PAUSE / UNPAUSE nu se potrivesc');
          }
          if (day.hasExtraMismatch){
            reasons.push('EXTRA START / EXTRA FINISH nu se potrivesc');
          }
          if (day.openRunning){
            reasons.push('Sesiune normƒÉ rƒÉmasƒÉ deschisƒÉ (START fƒÉrƒÉ FINISH)');
          }
          if (day.openExtra){
            reasons.push('Sesiune EXTRA rƒÉmasƒÉ deschisƒÉ');
          }
          if (day.pauseMs && day.pauseMs > pauseMarginMs){
            reasons.push('PauzƒÉ mai mare dec√¢t limita (' + fmtHoursHM(day.pauseMs) + ' > ' + fmtHoursHM(pauseMarginMs) + ')');
          }
          if (day.workMs && day.workMs > 12 * 60 * 60 * 1000){
            reasons.push('NormƒÉ foarte mare √Æn aceea»ôi zi (>12h)');
          }
          if (isWeekend(info.dateKey) && (day.workMs || day.extraMs)){
            reasons.push('Pontaj √Æn weekend');
          }

          if (!reasons.length) return;

          const isLeave = isEmployeeOnLeave(info.name, info.dateKey);

          rows.push({
            dateKey: info.dateKey,
            name: info.name,
            dept: day.dept || emp.dept || info.deptHint || '',
            work: day.workMs ? fmtHoursHM(day.workMs) : '',
            extra: day.extraMs ? fmtHoursHM(day.extraMs) : '',
            leave: isLeave ? 'DA' : 'NU',
            reasons: reasons.join('; ')
          });
        });

        rows.sort((a,b)=>{
          if (a.dateKey < b.dateKey) return -1;
          if (a.dateKey > b.dateKey) return 1;
          return a.name.localeCompare(b.name,'ro');
        });
        return rows;
      }

      function getSelectedEmployeeFromFilter(){
        const fs = getFilterState();
        if (fs.employee && fs.employee !== 'all') return fs.employee;
        return null;
      }

      function getDeptFromFilter(){
        const fs = getFilterState();
        if (fs.dept && fs.dept !== 'all') return fs.dept;
        return null;
      }

      let REPORTS_DATA_PROMISE = null;
      async function ensureReportsData(){
        if (REPORTS_DATA_PROMISE) return REPORTS_DATA_PROMISE;
        REPORTS_DATA_PROMISE = (async function(){
          const cfg = await loadConfig();
          applyNormSettingsFromConfig(cfg);

          let leavesData = null;
          if (cfg.leaveEndpoint){
            try{
              let leaveBase = cfg.leaveEndpoint.trim();
              if (leaveBase.indexOf('?') === -1){
                leaveBase += '?fn=adminLeave';
              } else if (!/[?&]fn=adminLeave\b/.test(leaveBase)){
                leaveBase += '&fn=adminLeave';
              }
              const leaveUrl = leaveBase + '&v=' + Date.now();
              const lr = await fetch(leaveUrl, {cache:'no-store'});
              const ltxt = await lr.text();
              let ljson = null;
              try{ ljson = JSON.parse(ltxt); }catch(e){}
              if (ljson && ljson.ok && Array.isArray(ljson.leaves)){
                leavesData = ljson.leaves;
              }
            }catch(_){}
          }
          buildLeaveIndex(leavesData || []);

          const baseUrl = getWebAppBaseUrl();
          const adminUrl = baseUrl + '?fn=adminEvents&v=' + Date.now();
          const r = await fetch(adminUrl, {cache:'no-store'});
          const txt = await r.text();
          let data;
          try{ data = JSON.parse(txt); }catch(e){ throw new Error('RƒÉspuns invalid de la adminEventsEndpoint.'); }
          if (!data || !data.ok || !Array.isArray(data.events)){
            throw new Error('adminEventsEndpoint nu a √Æntors un obiect ok cu events[].');
          }

          REPORT_EVENTS = data.events.map(ev => ({
            ts: ev.ts,
            name: ev.name || '',
            action: _normAction(ev.action),
            dept: ev.dept || '',
            activity: ev.activity || '',
            location: ev.location || ''
          })).filter(ev => ev.ts);

          REPORT_STATS = buildStatsFromEvents(REPORT_EVENTS);
          return true;
        })();
        return REPORTS_DATA_PROMISE;
      }

      // ===== Sesiune admin & DOM =====

      const session = getAdminSession();
      if (!session){
        alert('Nu e»ôti autentificat ca admin. Te redirec»õionez la pagina principalƒÉ.');
        window.location.href = 'index.html';
        return;
      }

      const adminLabelEl     = document.getElementById('adminLabel');
      const logoutBtn        = document.getElementById('logoutBtn');
      const dailyBtn         = document.getElementById('dailyReportBtn');
      const weeklyBtn        = document.getElementById('weeklyReportBtn');
      const monthlyBtn       = document.getElementById('monthlyReportBtn');
      const monthlyCurrentBtn= document.getElementById('monthlyCurrentReportBtn'); // NOU
      const rebuildBtn       = document.getElementById('rebuildReportBtn');
      const statusEl         = document.getElementById('reportsStatus');
      const logEl            = document.getElementById('reportsLog');
      const filesEl          = document.getElementById('reportsFiles');
      const exportCsvBtn         = document.getElementById('exportCsvBtn');
      const exportIncompleteBtn  = document.getElementById('exportIncompleteBtn');
      const exportAnomaliesBtn   = document.getElementById('exportAnomaliesBtn');
      const pdfBtn               = document.getElementById('pdfBtn');
      const deptPdfBtn           = document.getElementById('deptPdfBtn');
      const employeeExportBtn    = document.getElementById('employeeExportBtn');
      const payrollExportBtn     = document.getElementById('payrollExportBtn');

      if (adminLabelEl) adminLabelEl.textContent = session.user || 'Admin';

      if (logoutBtn){
        logoutBtn.addEventListener('click', function(){
          clearAdminSession();
          window.location.href = 'index.html';
        });
      }

      // DacƒÉ ai rol "viewer", nu are voie sƒÉ for»õeze rapoarte / exporturi
      if (session.role === 'viewer'){
        if (dailyBtn) dailyBtn.disabled = true;
        if (weeklyBtn) weeklyBtn.disabled = true;
        if (monthlyBtn) monthlyBtn.disabled = true;
        if (monthlyCurrentBtn) monthlyCurrentBtn.disabled = true;
        if (rebuildBtn) rebuildBtn.disabled = true;
        if (statusEl) statusEl.textContent = 'Rolul tƒÉu nu permite rularea manualƒÉ a rapoartelor.';
        if (exportCsvBtn)        exportCsvBtn.disabled = true;
        if (exportIncompleteBtn) exportIncompleteBtn.disabled = true;
        if (exportAnomaliesBtn)  exportAnomaliesBtn.disabled = true;
        if (pdfBtn)              pdfBtn.disabled = true;
        if (deptPdfBtn)          deptPdfBtn.disabled = true;
        if (employeeExportBtn)   employeeExportBtn.disabled = true;
        if (payrollExportBtn)    payrollExportBtn.disabled = true;
      }

      // ===== callReport: triggere de tip daily/weekly/monthly/rebuild =====

      async function callReport(fnKey, label){
        if (!statusEl) return;
        statusEl.textContent = 'Se ruleazƒÉ ' + label + '...';
        statusEl.style.color = 'var(--muted)';

        if (filesEl){
          filesEl.textContent = 'A»ôtept rƒÉspuns de la server pentru ' + label + '...';
        }

        const btns = [dailyBtn, weeklyBtn, monthlyBtn, monthlyCurrentBtn, rebuildBtn].filter(Boolean);
        btns.forEach(b => b.disabled = true);

        try{
          const cfg = await loadConfig();
          if (!cfg.adminEventsEndpoint){
            throw new Error('Lipse»ôte adminEventsEndpoint √Æn config.json.');
          }

          const baseUrl = getWebAppBaseUrl();
          const url = baseUrl +
            '?fn=' + encodeURIComponent(fnKey) +
            '&v=' + Date.now();

          appendLogLine(logEl, 'Trimit cerere cƒÉtre: ' + url);

          const resp = await fetch(url, {cache:'no-store'});
          const text = await resp.text();

          let data = null;
          try{
            data = JSON.parse(text);
          }catch(e){
            // nu e JSON, dar poate totu»ôi s-a executat
          }

          if (!resp.ok){
            throw new Error('HTTP ' + resp.status + ' ‚Äì ' + (data && data.error ? data.error : 'rƒÉspuns nevalid'));
          }

          if (data && data.ok === false){
            throw new Error(data.error || 'Serverul a √Æntors ok=false.');
          }

          const msg = (data && (data.message || data.status || data.msg)) || 'Rulare finalizatƒÉ.';
          statusEl.textContent = label + ': ' + msg;
          statusEl.style.color = '#166534';
          appendLogLine(logEl, label + ' OK: ' + msg);

          // Afi»ôeazƒÉ linkurile cƒÉtre PDF-urile generate
          if (filesEl){
            const files = data && Array.isArray(data.files) ? data.files : [];
            if (!files.length){
              filesEl.textContent = 'Rularea a fost finalizatƒÉ, dar nu am primit linkuri de rapoarte (vezi Google Drive).';
            } else {
              const items = files.map(function(f){
                const url = f.fileUrl || f.url;
                if (!url) return '';
                const parts = [];
                if (f.employee) parts.push(f.employee);
                if (f.dept) parts.push('[' + f.dept + ']');
                if (f.date) parts.push(f.date);
                if (f.weekLabel) parts.push(f.weekLabel);
                if (f.yearMonth) parts.push(f.yearMonth);
                const labelText = (f.fileName || parts.join(' ‚Ä¢ ') || 'DescarcƒÉ raport')
                  .replace(/</g,'&lt;').replace(/>/g,'&gt;');

                return '<li><a href="' + url +
                       '" target="_blank" rel="noopener">' +
                       labelText + '</a></li>';
              }).filter(Boolean).join('');

              filesEl.innerHTML =
                '<div class="admin-small-text" style="margin-top:4px;margin-bottom:2px;">' +
                  'Rapoarte generate la ultima rulare:' +
                '</div>' +
                '<ul class="reports-files-list">' + items + '</ul>';
            }
          }
        }catch(err){
          const m = err && err.message ? err.message : String(err);
          statusEl.textContent = label + ' ‚Äì eroare: ' + m;
          statusEl.style.color = '#b91c1c';
          appendLogLine(logEl, label + ' EROARE: ' + m);
          if (filesEl){
            filesEl.textContent = 'Nu am putut genera linkurile (eroare la rulare).';
          }
        }finally{
          btns.forEach(b => b.disabled = false);
        }
      }

      // ==== Butoane rapoarte ====

      if (dailyBtn){
        dailyBtn.addEventListener('click', function(){
          callReport('dailyReports', 'Raport zi (dailyReports)');
        });
      }
      if (weeklyBtn){
        weeklyBtn.addEventListener('click', function(){
          callReport('weeklyReports', 'Raport sƒÉptƒÉm√¢nƒÉ (weeklyReports)');
        });
      }
      if (monthlyBtn){
        monthlyBtn.addEventListener('click', function(){
          callReport('monthlyReports', 'Raport lunƒÉ (monthlyReports)');
        });
      }
      if (monthlyCurrentBtn){
        monthlyCurrentBtn.addEventListener('click', function(){
          callReport('monthlyReportsLatest', 'Raport lunar current (monthlyReportsLatest)');
        });
      }
      if (rebuildBtn){
        rebuildBtn.addEventListener('click', function(){
          callReport('rebuildReports', 'Rebuild statistici (rebuildReports)');
        });
      }

      // ==== Exporturi CSV / PDF ====

      if (exportCsvBtn){
        exportCsvBtn.addEventListener('click', async function(){
          try{
            await ensureReportsData();
            const events = getEventsForCurrentFilter();
            if (!events.length){
              alert('Nu existƒÉ evenimente √Æn filtrul curent (salvat din dashboard).');
              return;
            }
            const header = ['timestamp_iso','data_ora','nume','departament','actiune','activitate','locatie'];
            const rows = events.map(ev => [
              ev.ts || '',
              fmtDateTime(ev.ts) || '',
              ev.name || '',
              ev.dept || '',
              ev.action || '',
              ev.activity || '',
              ev.location || ''
            ]);
            exportCsvGeneric('pontaj-export-filtru-curent.csv', header, rows);
            if (statusEl){
              statusEl.textContent = 'Export CSV (filtru curent) generat.';
              statusEl.style.color = '#166534';
            }
          }catch(err){
            const m = err && err.message ? err.message : String(err);
            alert('Eroare la export CSV: ' + m);
          }
        });
      }

      if (exportIncompleteBtn){
        exportIncompleteBtn.addEventListener('click', async function(){
          try{
            await ensureReportsData();
            const rows = getIncompleteRowsForCurrentFilter();
            if (!rows.length){
              alert('Nu existƒÉ zile incomplete pentru filtrul curent.');
              return;
            }
            const header = ['Data','Nume','Departament','Norma','Extra','Concediu','Stare'];
            const csvRows = rows.map(x => [
              x.dateKey, x.name, x.dept, x.work, x.extra, x.leave, x.status
            ]);
            exportCsvGeneric('pontaj-zile-incomplete-filtru.csv', header, csvRows);
            if (statusEl){
              statusEl.textContent = 'Export zile incomplete generat.';
              statusEl.style.color = '#166534';
            }
          }catch(err){
            alert('Eroare la exportul zilelor incomplete: ' + (err.message || err));
          }
        });
      }

      if (exportAnomaliesBtn){
        exportAnomaliesBtn.addEventListener('click', async function(){
          try{
            await ensureReportsData();
            const rows = getAnomalyRowsForCurrentFilter();
            if (!rows.length){
              alert('Nu existƒÉ anomalii pentru filtrul curent.');
              return;
            }
            const header = ['Data','Nume','Departament','Norma','Extra','Concediu','Detalii'];
            const csvRows = rows.map(x => [
              x.dateKey, x.name, x.dept, x.work, x.extra, x.leave, x.reasons
            ]);
            exportCsvGeneric('pontaj-anomalii-filtru.csv', header, csvRows);
            if (statusEl){
              statusEl.textContent = 'Export anomalii generat.';
              statusEl.style.color = '#166534';
            }
          }catch(err){
            alert('Eroare la exportul anomaliilor: ' + (err.message || err));
          }
        });
      }

      if (pdfBtn){
        pdfBtn.addEventListener('click', async function(){
          const emp = getSelectedEmployeeFromFilter();
          if (!emp){
            alert('SelecteazƒÉ mai √Ænt√¢i un angajat √Æn filtrul din dashboard (Admin) »ôi apoi re√ÆncarcƒÉ aceastƒÉ paginƒÉ.');
            return;
          }
          try{
            const cfg = await loadConfig();
            if (!cfg.adminEventsEndpoint) throw new Error('Lipse»ôte adminEventsEndpoint.');
            const url = cfg.adminEventsEndpoint +
              (cfg.adminEventsEndpoint.includes('?') ? '&' : '?') +
              'fn=adminPdf&name=' + encodeURIComponent(emp) +
              '&v=' + Date.now();
            window.open(url, '_blank');
          }catch(err){
            alert('Eroare configurare PDF: ' + (err && err.message ? err.message : err));
          }
        });
      }

      if (deptPdfBtn){
        deptPdfBtn.addEventListener('click', async function(){
          let dept = getDeptFromFilter();
          if (!dept){
            const input = prompt('Introdu numele departamentului pentru raport (exact ca √Æn dashboard):','');
            dept = input ? input.trim() : '';
          }
          if (!dept){
            alert('Nu a fost ales niciun departament.');
            return;
          }
          try{
            const cfg = await loadConfig();
            if (!cfg.adminEventsEndpoint) throw new Error('Lipse»ôte adminEventsEndpoint.');
            const url = cfg.adminEventsEndpoint +
              (cfg.adminEventsEndpoint.includes('?') ? '&' : '?') +
              'fn=adminPdfDept&dept=' + encodeURIComponent(dept) +
              '&v=' + Date.now();
            const r   = await fetch(url, {cache:'no-store'});
            const resp= await r.json();
            if (!resp.ok || !resp.url){
              throw new Error(resp.error || 'Nu am primit un URL de raport.');
            }
            window.open(resp.url, '_blank');
          }catch(err){
            alert('Eroare la generarea raportului departamental: ' + (err.message || err));
          }
        });
      }

      if (employeeExportBtn){
        employeeExportBtn.addEventListener('click', async function(){
          try{
            await ensureReportsData();
            if (!REPORT_STATS || !REPORT_STATS.employees || !REPORT_STATS.employees.size){
              alert('Nu existƒÉ statistici pentru export.');
              return;
            }
            const empName = getSelectedEmployeeFromFilter();
            if (!empName){
              alert('SelecteazƒÉ mai √Ænt√¢i un angajat √Æn dashboard (filtru Angajat).');
              return;
            }
            const emp = REPORT_STATS.employees.get(empName);
            if (!emp){
              alert('Nu gƒÉsesc date pentru acest angajat.');
              return;
            }
            const t   = emp.totals;
            const daysArr = Array.from(emp.days.values())
              .sort((a,b)=>a.dateKey < b.dateKey ? -1 : (a.dateKey > b.dateKey ? 1 : 0));

            const totalNormH = msToHours(t.totalWorkMs);
            const totalExtraH= msToHours(t.totalExtraMs);
            const totalOverH = msToHours(t.overtimeMs);
            const pctComplete = t.daysWithStart ? Math.round(100 * t.daysCompleted / t.daysWithStart) : 0;

            const header = [
              'Nume','Departament','Total ore norma (h)','Total ore extra (h)',
              'Total overtime (h)','Zile cu START','Zile cu FINISH','Zile complete',
              'Zile cu norma validata','Procent zile complete (%)',
              'Data','Norma (h)','Extra (h)','Overtime (h)','Complet','Norma validata'
            ];

            const rows = daysArr.map(d => {
              const flagIncomplete = isDayIncomplete(d);
              return [
                emp.name,
                emp.dept || '',
                totalNormH.toFixed(2),
                totalExtraH.toFixed(2),
                totalOverH.toFixed(2),
                t.daysWithStart,
                t.daysWithFinish,
                t.daysCompleted,
                t.normValidatedDays,
                pctComplete,
                d.dateKey,
                (msToHours(d.workMs) || 0).toFixed(2),
                (msToHours(d.extraMs) || 0).toFixed(2),
                (msToHours(d.overtimeMs) || 0).toFixed(2),
                d.completed ? 'DA' : (flagIncomplete ? ('INCOMPLETA: ' + getIncompleteReasons(d).join('; ')) : '-'),
                d.normValidated ? 'VALIDATA' : 'NU'
              ];
            });

            exportCsvGeneric('pontaj-' + empName.replace(/\s+/g,'_') + '.csv', header, rows);
            if (statusEl){
              statusEl.textContent = 'Export CSV angajat (all time) generat pentru ' + empName + '.';
              statusEl.style.color = '#166534';
            }
          }catch(err){
            alert('Eroare la exportul pe angajat: ' + (err.message || err));
          }
        });
      }

      if (payrollExportBtn){
        payrollExportBtn.addEventListener('click', async function(){
          try{
            await ensureReportsData();
            const now = new Date();
            let year = now.getFullYear();
            let month = now.getMonth() - 1;
            if (month < 0){
              month = 11;
              year--;
            }
            const start = new Date(year, month, 1, 0,0,0);
            const end   = new Date(year, month+1, 0, 23,59,59,999);
            const monthLabel = String(month+1).padStart(2,'0') + '.' + year;

            const confirmMsg = 'Generezi exportul de salarizare pentru luna ' + monthLabel + '?';
            if (!confirm(confirmMsg)) return;

            const subset = (REPORT_EVENTS || []).filter(ev=>{
              if (!ev.ts) return false;
              const t = new Date(ev.ts);
              if (isNaN(t.getTime())) return false;
              return t >= start && t <= end;
            });
            if (!subset.length){
              alert('Nu existƒÉ pontaje √Æn luna ' + monthLabel + ' pentru export.');
              return;
            }
            const statsMonth = buildStatsFromEvents(subset);
            if (!statsMonth.employees || !statsMonth.employees.size){
              alert('Nu existƒÉ date agregate pentru aceastƒÉ lunƒÉ.');
              return;
            }

            const header = [
              'Luna',
              'Nume',
              'Departament',
              'Total ore normƒÉ (h)',
              'Total ore extra (h)',
              'Total overtime (h)',
              'Zile cu START',
              'Zile cu FINISH',
              'Zile complete',
              'Zile cu normƒÉ validatƒÉ'
            ];

            const rows = [];
            statsMonth.employees.forEach(emp=>{
              const t = emp.totals;
              rows.push([
                monthLabel,
                emp.name,
                emp.dept || '',
                msToHours(t.totalWorkMs).toFixed(2),
                msToHours(t.totalExtraMs).toFixed(2),
                msToHours(t.overtimeMs).toFixed(2),
                t.daysWithStart,
                t.daysWithFinish,
                t.daysCompleted,
                t.normValidatedDays
              ]);
            });

            exportCsvGeneric(
              'pontaj-salarizare-' + year + '-' + String(month+1).padStart(2,'0') + '.csv',
              header,
              rows
            );
            if (statusEl){
              statusEl.textContent = 'Export salarizare (luna precedentƒÉ) generat.';
              statusEl.style.color = '#166534';
            }
          }catch(err){
            alert('Eroare la exportul de salarizare: ' + (err.message || err));
          }
        });
      }

    })();
  </script>
</body>
</html>
